from flask import Flask, jsonify, request, render_template, url_for, flash, redirect
from flask_cors import CORS
from flask_login import LoginManager, login_required, current_user

import os
from dotenv import load_dotenv
from config.portals import INTERNAL_TOOLS
from service.csv_service import get_all_log_records, get_all_servers_for_user
from service.remove_user import remove_user_from_server
from utils.get_group_list import get_group_list
from utils.validators import validate_ip, validate_username, validate_pub_key  
from utils.group_ip_provider import get_ips_from_group
from service.create_user import create_user_on_server
import logging

from config.portals import INTERNAL_TOOLS
from auth.routes import auth_bp
from auth.user import User 

logging.basicConfig(
    level=logging.INFO, 
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/app.log'), 
        logging.StreamHandler() 
    ]
)
logger = logging.getLogger(__name__)  

load_dotenv()

app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')
if not app.config['SECRET_KEY']:
    logger.critical("FATAL ERROR: SECRET_KEY not set in environment variables.")
    # In a real app, you might exit here or raise a more specific exception
    raise ValueError("SECRET_KEY is not set. Cannot run Flask securely.")

CORS(app)

# --- Flask-Login Setup ---
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'auth.login' # The FUNCTION NAME for the login route (blueprint.view_func)
login_manager.login_message = "You must be logged in to access this page."
login_manager.login_message_category = "warning" # category for flash message

@login_manager.user_loader
def load_user(user_id):
    """Flask-Login required callback to load a user from the session."""
    return User.get(user_id)

# --- Register Blueprints ---
app.register_blueprint(auth_bp) # Register the auth blueprint
# --- End Blueprints ---

@app.route('/')
@login_required
def home():
    """Serves the home page dashboard."""
    logger.info(f"User '{current_user.id}' accessed the home page.")
    # Prepare tools data with actual URLs generated by url_for
    tools_with_urls = []
    for tool in INTERNAL_TOOLS:
        try:
            # Copy the tool dict and add the generated URL
            tool_data = tool.copy() 
            if tool.get('url_endpoint') and tool['url_endpoint'] in app.view_functions:
                 tool_data['url'] = url_for(tool['url_endpoint'])
            else:
                 tool_data['url'] = '#' # Default if endpoint is missing or invalid
                 logger.warning(f"URL endpoint '{tool.get('url_endpoint', 'N/A')}' not found for tool '{tool.get('name', 'N/A')}'.")
            tools_with_urls.append(tool_data)
        except Exception as e:
            logger.error(f"Could not generate URL for tool endpoint '{tool.get('url_endpoint', 'N/A')}': {e}")
            tool_data = tool.copy()
            tool_data['url'] = '#'
            tools_with_urls.append(tool_data)

    return render_template('home.html', tools=tools_with_urls)

@app.route('/accesspoint', methods=['GET'])
@login_required
def accesspoint():
    """Serves the access point page."""
    logger.info(f"User '{current_user.id}' accessed Access Point main page.")
    return render_template('accesspoint.html')

@app.route('/api/get-user-ips/<username>', methods=['GET'])
@login_required
def get_user_ips_api(username):
    """API endpoint to fetch the list of IPs associated with a username."""
    logger.info(f"API request by '{current_user.id}' for IPs of user: {username}")
    try:
        if not validate_username(username): # Validate username format first
            logger.warning(f"Invalid username format requested: {username}")
            return jsonify({'error': 'Invalid username format.'}), 400
    
        ips = get_all_servers_for_user(username)
        if not ips:
            logger.info(f"No servers found for username: {username}")
            return jsonify({'message': f'No active servers found for username "{username}".'}), 404
        else:
            logger.info(f"Found {len(ips)} servers for user {username}: {ips}")
            return jsonify({'ips': ips}), 200
    except Exception as e:
        logger.exception(f"Error fetching IPs for user {username}: {str(e)}")
        return jsonify({'error': 'Server error retrieving IP list.'}), 500

@app.route('/accesspoint/giveaccess', methods=['POST', 'GET'])
@login_required
def create_user():
    """API endpoint to create a user on multiple servers."""   
    try: 
        if request.method == 'GET':
            logger.info(f"User '{current_user.id}' accessed the give access form.")
            available_groups = get_group_list()
            logger.info("Serving give access form.")
            return render_template('giveaccess.html', available_groups=available_groups)
        
        # POST logic
        logger.info(f"Received POST request on /accesspoint/giveaccess from user '{current_user.id}'")
        data = request.get_json()
        if not data or 'username' not in data or 'pub_key' not in data:  
            message = 'Invalid request payload. Missing username or public key'
            logger.warning(message)
            return jsonify({'error': message}), 400

        username = data.get('username')
        group_string = data.get('groups', '')
        manual_ip_string = data.get('ips', '')
        pub_key = data.get('pub_key')
        add_to_sudoers = data.get('add_to_sudoers', False)  

        if not validate_username(username):
            message = 'Invalid username. Use only letters, numbers, underscores, and hyphens'
            logger.warning(message)
            return jsonify({'error': message}), 400

        if not validate_pub_key(pub_key):
            message = 'Invalid public key format'
            logger.warning(message)
            return jsonify({'error': message}), 400
        
        ips = []
        
        if group_string:
            groups = [group.strip() for group in group_string.split(',') if group.strip()]
            for group in groups:
                group_ips = get_ips_from_group(group)
                ips.extend(group_ips)

        if manual_ip_string:
            manual_ips = [ip.strip() for ip in manual_ip_string.split(',') if ip.strip()]
            for ip in manual_ips:
                if validate_ip(ip):
                    ips.append(ip)
                else:
                    message = f'Invalid IP address: {ip}'
                    logger.warning(message)
                    return jsonify({'error': message}), 400
                
        ips = list(set(ips))
        if not ips:
            message = 'At least one IP is required'
            logger.warning(message)
            return jsonify({'error': message}), 400

        results = {}
        all_success = True
        for ip in ips:
            success, message = create_user_on_server(ip, username, pub_key, add_to_sudoers)
            results[ip] = {'success': success, 'message': message}
            if not success:
                all_success = False
                logger.error(f"Failed to create user {username} on {ip}: {message}")
            else:
                logger.info(f"Successfully processed user {username} on {ip}: {message}")

        response_data = {
                'message': 'Access request processed. See details below.',
                'results': results, 
                'all_success': all_success
            }
        status_code = 200 if all_success else 207 

        return jsonify(response_data), status_code

    except Exception as e:
        logger.exception(f"An error occurred during give access POST by {current_user.id if current_user.is_authenticated else 'anonymous'}: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/accesspoint/removeaccess', methods=['POST', 'GET'])
@login_required
def remove_user():
    """API endpoint to remove a user from multiple servers."""
    try:
        if request.method == 'GET':
            logger.info(f"User '{current_user.id}' accessed the remove access form.")
            return render_template('removeaccess.html')
    
        if request.method == 'POST':
            logger.info(f"Received POST request on /accesspoint/removeaccess from user '{current_user.id}'")
            data = request.get_json()
            if not data or 'username' not in data or 'ips' not in data:
                message = 'Invalid request payload. Missing username or ips list.'
                logger.warning(message)
                return jsonify({'error': message}), 400

            username = data.get('username')
            ips_to_remove = data.get('ips', [])

            # Validation
            if not validate_username(username):
                message = 'Invalid username.'
                logger.warning(message)
                return jsonify({'error': message}), 400
            if not isinstance(ips_to_remove, list):
                 message = 'Invalid format for IPs - expected a list.'
                 logger.warning(message)
                 return jsonify({'error': message}), 400
            if not ips_to_remove:
                message = 'No IP addresses were selected for removal.'
                logger.warning(message)
                return jsonify({'error': message}), 400 # Bad request if no IPs selected
            invalid_ips = [ip for ip in ips_to_remove if not validate_ip(ip)]
            if invalid_ips:
                message = f'Invalid IP address format submitted: {", ".join(invalid_ips)}'
                logger.warning(message)
                return jsonify({'error': message}), 400
            # End of validation
            
            logger.info(f"Processing removal request for user : '{username}'.")

            results = {}
            all_success = True
            action_by_user = current_user.id if current_user.is_authenticated else 'anonymous'

            for ip in ips_to_remove:
                success, message = remove_user_from_server(ip, username,action_by_user) 
                results[ip] = {'success': success, 'message': message}
                if not success:
                    all_success = False
                    logger.error(f"Failed to remove user {username} from {ip} by {action_by_user}: {message}")
                else:
                    logger.info(f"Successfully processed removal for user {username} from {ip} by {action_by_user}: {message}")
                    # NOTE: The remove_user_from_server function itself should handle updating the CSV log

            response_data = {
                'message': 'User removal process completed. See details below.',
                'results': results,
                'all_success': all_success
            }
            status_code = 200 if all_success else 207 # 207 Multi-Status

            return jsonify(response_data), status_code
        else:
            message = 'Invalid request method. Only POST is allowed.'
            logger.warning(message)
            return jsonify({'error': message}), 405
    except Exception as e:
        logger.exception(f"An error occurred during user removal POST by {current_user.id if current_user.is_authenticated else 'anonymous'}: {str(e)}")
        return jsonify({'error': f'An unexpected server error occurred: {str(e)}'}), 500
    
@app.route('/accesspoint/logs')
@login_required
def logs_page():
    """Serves the page displaying the current access records by calling the CSV service."""
    logger.info(f"User '{current_user.id}' accessed the Current Access Report page.")
    log_data, error_message = get_all_log_records()
    return render_template('logs.html', logs_data=log_data, error_message=error_message)

@app.errorhandler(401) # Unauthorized
def unauthorized_access(error):
    logger.warning(f"Unauthorized access attempt to {request.path}")
    flash("You need to be logged in to access this page.", "warning")
    return redirect(url_for('auth.login', next=request.url))

@app.errorhandler(404) # Not Found
def page_not_found(error):
    logger.warning(f"404 Not Found error for URL: {request.path}")
    return render_template('errors/404.html'), 404 # Create a simple 404 template

@app.errorhandler(500) # Internal Server Error
def internal_server_error(error):
    logger.error(f"500 Internal Server Error: {error}", exc_info=True)
    return render_template('errors/500.html'), 500 # Create a simple 500 template


if __name__ == '__main__':
    if not app.config.get('SECRET_KEY'):
        print("FATAL ERROR: SECRET_KEY is not configured. Exiting.")
    app.run(debug=True, host='0.0.0.0', port=int(os.getenv('APP_PORT', 5000)))